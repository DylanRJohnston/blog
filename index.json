[{"content":"Introduction The other day I was reading this blog post covering existential types in Rust (also known as impl Trait or opaque types). In that blog post, the author makes the following claim.\nWe’re going to have to take a slight diversion into type theory here because it motivates a result that is perhaps intuitive. The following proposition holds in intuitionistic logic: ((∃ x. P(x)) → Q) ⇔ (∀ x. (P(x) → Q)), which means that according to the Curry–Howard Correspondence, it also holds when considering the proposition as a type.\nIn particular the ((∃ x. P(x)) → Q) ⇔ (∀ x. (P(x) → Q)) caught my eye. While I was working for Originate in San Francisco back in 2017 I used my 20% time project to study Benjamin C. Pierce\u0026rsquo;s excellent Software Foundations series which teaches how to structure and formally verify software using the Coq Proof Assistant (yes, it\u0026rsquo;s pronounced exactly how think, 🙄). It completely changed the way I look at programming for the better but it\u0026rsquo;s not a skill that I get to practice regularly and as you get older you have to either use it or lose it. So I thought I\u0026rsquo;d try my hand at seeing if I remembered enough of Coq to be able to prove the above statement.\nTrait Dispatch in Rust To understand why we even care about the above proposition, it\u0026rsquo;s worth taking a moment to understand how impl Trait is used in Rust, if you\u0026rsquo;re not interested in Rust and just want to get to the Coq tutorial you should skip this section and jump head to #Coq\nIn Rust, to abstract over common functionality, we have Traits (interfaces in most other languages). Below is the simple ToString trait from the standard library.\ntrait ToString { fn to_string(\u0026amp;self) -\u0026gt; String; } If we want to write a function that accepts things that can be turned into strings we have a few different options depending on whether we want static or dynamic dispatch. To demonstrate the available options we\u0026rsquo;ll use a contrived toy function yell which turns the input into a string, convert it to all caps, and prints it to stdout.\nStatic Dispatch fn yell\u0026lt;S: ToString\u0026gt;(stringable: S) { println!(stringable.to_string().to_uppercase()) } In Rust, generics are monomorphised. The compiler will create a copy and unique name for each type the function is called with, meaning each method call on the trait points to one, and only one function so the call can be statically dispatched. For example\nyell(42); yell(\u0026#34;According to all known laws of aviation ...\u0026#34;); This will result in the creation of two functions for each call\nfn yell__i32(stringable: i32) { println!(stringable.to_string().to_uppercase()) } fn yell__at_str(stringable: \u0026amp;str) { println!(stringable.to_string().to_uppercase()) } transforming the call site also into their respective monomorphised functions\nyell__i32(42); yell__at_str(\u0026#34;According to all known laws of aviation ...\u0026#34;); So when we call the trait method to_string() in each of those monomorphised functions, the rust compiler knows precisely which function call to make and doesn\u0026rsquo;t require chasing pointers (dynamic dispatch). It also means the stack layouts of calling those functions can differ but we\u0026rsquo;ll get into that in a moment when talking about trait objects and object safety (spoilers!).\nDynamic Dispatch Another way to write our yell function is\nfn yell(stringable: \u0026amp;dyn ToString) { println!(stringable.to_string().to_uppercase()) } which from the name of this subsection and the use of the dyn keyword may have tipped you off to the fact it uses dynamic dispatch. If you\u0026rsquo;re familiar with how interfaces work in Golang then you already know what\u0026rsquo;s going on here.\nIn this case, rust doesn\u0026rsquo;t copy the yell method for each type it\u0026rsquo;s called with but instead \u0026amp;dyn ToString is often what\u0026rsquo;s known as a \u0026ldquo;fat pointer\u0026rdquo;. In that, it contains two pointers, one to the data, and one to the vtable for the methods of the trait.\np l o e i n \u0026amp; n g s t t t e h r r v d t s a a t t b r a l i e n p g o p a i o b n i l t n e e t r e r d s a t e i l o s z i _ v t e g s t r n t a u m r b c e i l t n n e o t g r ( ) It\u0026rsquo;s called \u0026ldquo;dynamic dispatch\u0026rdquo; because we don\u0026rsquo;t know which function we\u0026rsquo;re going to call until runtime when we follow the vtable pointer to find the particular to_string() method we\u0026rsquo;re going to call. Most of the time the overhead of this pointer chasing doesn\u0026rsquo;t matter and your application probably has performance bottlenecks elsewhere, but sometimes every pointer dereference counts.\nObject Saftey Beyond questionably legitimate concerns about performance, when you stop to think about how the compiler would layout the stack to call a dynamically dispatched function you may realise a fairly large limitation on what kinds of traits can be dynamically dispatched. They have to be the same size! Or more precisely, the function inputs and outputs must all be of the same size!\nThink about the following trait from the standard library\npub trait Clone { fn clone(\u0026amp;self) -\u0026gt; Self; } What is the amount of space we need to leave on the stack when calling clone()? Well, it returns Self, which is whatever the type that implements clone is, so i32, i64, or String all take up different amounts of space on the stack so it\u0026rsquo;s impossible for us to figure out how to layout the stack at compile time when we don\u0026rsquo;t know the size of the type until runtime! This is what\u0026rsquo;s known in rust as Object Saftey. A trait that is not Object Safe contains methods with either its arguments or return values that do not have a constant size across all their possible implementations and therefore it is not safe to turn them into a Trait Object for dynamic dispatch.\nIn addition to trait methods that return Self, trait methods involving generic arguments or return values are also not \u0026ldquo;object safe\u0026rdquo; because the generic methods cannot be monomorphised behind a dynamic dispatch as it brushes up against the halting problem trying to figure how many entries of the monomorphised method are required in the vtable. If you tried to populate the vtable with every possible type in your application for each generic method it would grow enormous!\nimpl Trait So now we understand that sometimes we cannot even use dynamic dispatch even if we don\u0026rsquo;t care about the overhead from pointer chasing. We\u0026rsquo;re stuck with going back to our static dispatch approach of monomorphising generic functions.\nfn yell\u0026lt;S: ToString\u0026gt;(stringable: S) { println!(stringable.to_string().to_uppercase()) } The additional syntactic and mental overhead of tracking those generic parameters isn\u0026rsquo;t so bad with a single generic parameter, but as the number of generic parameters grows, it can become unwieldy. For example, this function is taken from an application I\u0026rsquo;m working on that connects several different financial applications and follows the Ports and Adapters (also known as Clean or Hexagonal architecture) pattern of hiding concrete side effects behind simple interfaces and injecting them as needed.\npub fn process\u0026lt;E, B, S\u0026gt;( config: transformer::Config, expense_tracker: E, budget: B, state: S, ) -\u0026gt; Result\u0026lt;()\u0026gt; where E: ExpenseTracker, B: Budget, S: State, { ... } I don\u0026rsquo;t know about you, but I find that kind of hard to read, especially since we\u0026rsquo;re introducing generic parameters, E, B, and S and only at the end of the function definition are we giving them proper constraints. Luckily Rust has an answer! impl Trait. We can instead rewrite the above function as.\npub fn process( config: transformer::Config, expense_tracker: impl ExpenseTracker, budget: impl Budget, state: impl State, ) -\u0026gt; Result\u0026lt;()\u0026gt; With this in mind you might be asking yourself why would you ever using dynamic dispatch over static. The main reason is when the dispatch is well, dynamic! Such as when you have a collection of trait objects.\nfn example() { let string = \u0026#34;hello\u0026#34;; let integer = 3 as i32; let collection: Vec\u0026lt;\u0026amp;dyn ToString\u0026gt; = vec![\u0026amp;string, \u0026amp;integer]; } Comparatively it is not possible to create a collection using impl Trait, nor is it possible to express this with generic constraints because the underlying opaque but concrete types are of different sizes.\nfn first() -\u0026gt; impl ToString { \u0026#34;According to all known laws of aviation ...\u0026#34; } fn second() -\u0026gt; impl ToString { 42 } fn example() { vec![first(), second()]; // Error ^^^ // mismatched types // expected opaque type `impl ToString` (opaque type at \u0026lt;src/main.rs:1:15\u0026gt;) // found opaque type `impl ToString` (opaque type at \u0026lt;src/main.rs:4:16\u0026gt;) // distinct uses of `impl Trait` result in different opaque types } But how to understand what impl Trait means? One way to understand it is it\u0026rsquo;s saying that there exists a type (unnamed) that implements the trait, the fact that it\u0026rsquo;s unnamed is why impl Trait is often referred to as opaque types, or existential types. We\u0026rsquo;re taking for granted that a type, some type, exists that satisfies this trait, but is it always safe to take the prior generic function and transform it into the existential form and vice versa? The introductory paragraph claims that it always is ((∃ x. P(x)) → Q) ⇔ (∀ x. (P(x) → Q)), but let\u0026rsquo;s not take some guy\u0026rsquo;s word for it, we can do better! Let\u0026rsquo;s prove it!\nCoq The Coq toolchain is a bit tricky to set up locally, but luckily we don\u0026rsquo;t have to as there\u0026rsquo;s an excellent online IDE that you can use instead. To translate our position into a form that Coq understands we can write\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. First, let\u0026rsquo;s take a second to understand our proposed theorem.\nforall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Firstly forall (Trait: Type -\u0026gt; Prop) (Result: Prop) is saying that what we want to prove should be true for every possible Trait method, and any possible return value of that Trait method, we can\u0026rsquo;t rely on anything true about any particular trait, our results are universal.\nsplit Our proposition is then broken into two halves separated by \u0026lt;-\u0026gt;. This is known as material equivalence, or \u0026ldquo;if and only if\u0026rdquo;, which is to say the left is true, if and only if the right is true, and visa versa. Therefore to prove it, we have to prove that the left proposition implies the right proposition, and also prove that the right proposition implies the left proposition. So we started trying to prove one thing, and now we have to prove two things! This process is very common in formal verification. To prove your goal, you have to break it apart and prove sub-sections of it. To prove the A \u0026amp; B you have to prove A, and you have to prove B, to prove A | B you can take your pick of A or B whichever you think is easier to prove.\nSo now we have to prove\n- (exists t, Trait(t)) -\u0026gt; Result) -\u0026gt; (forall t, (Trait(t) -\u0026gt; Result) - (forall t, (Trait(t) -\u0026gt; Result) -\u0026gt; (exists t, Trait(t)) -\u0026gt; Result) A transformation in Coq is called a Tactic. The tactic for splitting our goal into two separate goals like this is unsurprisingly called split. To evaluate your proof up to where your cursor is press CMD+Enter. You should see the goals screen on the right update to reflect the new state of trying to prove our theorem.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. Should give the output in the goals panel of\n2 goals Trait : Type -\u0026gt; Prop Result : Prop ------------------------ (exists t : Type, Trait t) -\u0026gt; Result) -\u0026gt; forall t : Type, Trait t -\u0026gt; Result subgoal 2 is: (forall t : Type, Trait t -\u0026gt; Result) -\u0026gt; (exists t : Type, Trait t) -\u0026gt; Result First Goal To focus on one goal at a time we use - to denote each branch of the proof. We\u0026rsquo;ll use it to focus on the first part of our proof.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - Tactic intros 1 2 3 4 5 1 goal Trait: Type -\u0026gt; Prop Result: Prop ------------------------ ((exists t : Type , Trait t) -\u0026gt; Result) -\u0026gt; forall t : Type , Trait t -\u0026gt; Result The way to understand trying to prove an implication like A -\u0026gt; B -\u0026gt; C, is that we get to assume, A, and B, when trying to prove C. So with the above goal, we get to assume we already have the two antecedent terms ((exists t : Type , Trait t) -\u0026gt; Result) and forall t : Type , Trait t. The tactic that lets us do this is called intro for one variable at a time, or intros if you want to \u0026ldquo;introduce\u0026rdquo; multiple at the same time. Naming these implied assumptions is hard so feel free to name them however you want or leave it blank and let Coq auto name them.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - intros existsTrait type trait. Tactic apply 1 goal Trait : Type -\u0026gt; Prop Result : Prop existsTrait : (exists t : Type, Trait t) -\u0026gt; Result type : Type trait : Trait type ------------------------ Result Implications work the opposite way when they\u0026rsquo;re in our assumptions. Right now our goal is to make a Result, in our assumptions we have an implication existsTrait : (exists t : Type, Trait t) -\u0026gt; Result which can give us a Result if we\u0026rsquo;re able to prove its antecedent. So by \u0026ldquo;applying\u0026rdquo; our assumption, we can shift our goal to trying to prove the assumptions antecedent. Maybe it\u0026rsquo;s a dead end and we\u0026rsquo;ll have to backtrack, but Result doesn\u0026rsquo;t appear anywhere else in our assumptions so it\u0026rsquo;s worth a try. The tactic to do this is unsurprisingly called apply.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - intros existsTrait type trait. apply existsTrait. Tactic exists 1 goal Trait : Type -\u0026gt; Prop Result : Prop existsTrait : (exists t : Type, Trait t) -\u0026gt; Result type : Type trait : Trait type ------------------------ exists t : Type, Trait t Now our goal is exists t : Type, Trait t, much like forall and intros, there exists a tactic for dealing with existentially quantified variables, called exists. Although unlike intros, which give us new assumptions, exists demands that we prove that a term exists. It is in some sense the opposite of forall/intros, it consumes a term rather than giving us one. Luckily, after examining our assumptions, we can see that our previous intros gave us an assumption of kind type : Type that matches the kind demanded by the \u0026ldquo;exists\u0026rdquo;. So we can get rid of it with exists.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - intros existsTrait type trait. apply existsTrait. exists type. Tactic assumption 1 goal Trait : Type -\u0026gt; Prop Result : Prop exists : Trait(exists t : Type, Trait t) -\u0026gt; Result type : Type trait : Trait type ------------------------ Trait type Now you may notice that our goal exactly matches one of our assumptions. So we can use the tactic assumption to finish this branch of the proof! One down and one to go!\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - intros existsTrait type trait. apply existsTrait. exists type. assumption. - Second Goal 1 goal Trait : Type -\u0026gt; Prop Result : Prop ------------------------ (forall t : Type, Trait t -\u0026gt; Result) -\u0026gt; (exists t : Type, Trait t) -\u0026gt; Result Now we\u0026rsquo;re proving that the material equivalence holds in the other direction, and just like the first branch we use intros to move the left-hand side of the implications into our assumptions.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. Tactic destruct 1 goal Trait : Type -\u0026gt; Prop Result : Prop anyTrait : forall t : Type , Trait t -\u0026gt; Result existsTrait : exists t : Type, Trait t ------------------------ Result At this point you might be tempted to try and apply anyTrait just like we did for our first goal, trying to switch the goal from result to forall t : Type , Trait t, however, this doesn\u0026rsquo;t work with Coq complaining that Unable to find an instance for the variable t. This is because t is still universally quantified right now, whereas in our first goal t was existentially quantified. So we\u0026rsquo;re going to need to find ourselves a t: Type before we can shift our goal.\nWe also have the existsTrait: exists t : Type, Trait t assumption. Luckily, when we have a term like this, we can ask Coq if this expression implies anything else that is not currently in our assumptions. We do this with the inversion or destruct tactics. Coq will auto-name the new assumptions but we can also give them meaningful names with as.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. destruct existsTrait as (t, trait). Tactic apply _ with _ Trait : Type -\u0026gt; Prop Result : Prop anyTrait : forall t : Type, Trait t -\u0026gt; Result t : Type trait : Trait type ------------------------ Result Coq has broken apart existsTrait into its two assumptions. So now we have an assumption of kind Type! We can now solve the problem we had before about applying anyTrait.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. destruct existsTrait as (t, trait). apply anyTrait with t. Tactic assumption Trait : Type -\u0026gt; Prop Result : Prop anyTrait : forall t : Type, Trait t -\u0026gt; Result t : Type trait : Trait t ------------------------ Trait t Now just like before, our goal matches one of our assumptions, so we can finish up this branch with assumption.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. destruct existsTrait as (t, trait). apply anyTrait with t. assumption. QED No more goals. Now that we\u0026rsquo;re proved all of our goals, we get to do the best thing about formal verification. The sweet three-letter acronym. QED.\nTheorem impl_trait_transform: forall (Trait: Type -\u0026gt; Prop) (Result: Prop), ((exists t, Trait(t)) -\u0026gt; Result) \u0026lt;-\u0026gt; (forall t, (Trait(t) -\u0026gt; Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. destruct existsTrait as (t, trait). apply anyTrait with t. assumption. Qed. Conclusion And there you go, we\u0026rsquo;ve formally verified that our transformation from generic arguments with trait bounds into existential impl Trait arguments is always valid. Of course, Rust would not have implemented the feature had it not made sense, but I think it\u0026rsquo;s gratifying to be able to prove such a cryptic statement like ((∃ x. P(x)) → Q) ⇔ (∀ x. (P(x) → Q))\nHopefully, this has given you a bit of a taste of how to reason when it comes to formally verify programs which is such an alien style of programming. I\u0026rsquo;ve always likened it to playing with Legos where the bricks are parts of your program. You know the final shape you want, you just have to keep exploring how they combine to get there.\nIf you\u0026rsquo;d like to explore more formal verification I\u0026rsquo;d highly recommend checking out Software Foundations or Edwin Brady\u0026rsquo;s Type-Driven Development with Idris.\n","permalink":"https://dylanj.xyz/posts/rust-coq-opaque-types/","summary":"Introduction The other day I was reading this blog post covering existential types in Rust (also known as impl Trait or opaque types). In that blog post, the author makes the following claim.\nWe’re going to have to take a slight diversion into type theory here because it motivates a result that is perhaps intuitive. The following proposition holds in intuitionistic logic: ((∃ x. P(x)) → Q) ⇔ (∀ x. (P(x) → Q)), which means that according to the Curry–Howard Correspondence, it also holds when considering the proposition as a type.","title":"Formally Verifying Rust's Opaque Types"},{"content":"Plan of Attack When evaluating options for starting a blog I wanted something that was fast, free, and easy to setup CI / CD for. GitHub Pages ticks both the free and easy boxes but it can be a bit slow to respond. To solve the speed issue I stuck cloudflare in front of GitHub to leverage its CDN caching, ensuring that response times are fast.\n┌ │ │ │ └ ┌ │ └ ─ ─ ─ ─ ─ d ─ ─ U ─ ─ y ─ ─ s ─ ─ l ─ ─ e ─ ─ G a ─ ─ r ─ ─ i n ─ ─ ─ ─ t r ─ ┐ ├ ┘ ─ H j ─ ─ ─ u o ─ ─ ─ b h ─ ─ ─ n ─ ─ ─ R s ─ ─ ─ e t ─ ┌ │ ► │ └ ─ p o ─ ─ ─ ─ o n ─ ─ C N ─ ─ s . ─ ─ l a ─ ─ i g ─ ─ o m ─ ─ t i ─ ─ u e ─ ─ o t ─ ─ d s ─ ─ r h ─ ─ f e ─ ─ y u ─ ─ l r ─ ─ b ─ ─ a v ─ ─ . ─ ─ r e ─ ─ i ─ ─ e r ─ ─ o ─ ─ ─ ─ ─ ┐ │ ├ │ ┘ ┐ │ ├ │ ┘ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┌ ► └ ┌ │ ► │ └ ─ ─ ─ ─ ─ G ─ ─ C ─ ─ i ─ ─ l ─ ─ t ─ ─ o ─ ─ H ─ ─ u C ─ ─ u ─ ─ d D ─ ─ b ─ ─ f N ─ ─ ─ ─ l ─ ─ A ─ ─ a ─ ─ c ─ ─ r ─ ─ t ─ ─ e ─ ─ i ─ ─ ─ ─ o ─ ┐ │ ├ │ ┘ ─ n ─ ─ ─ s ─ ─ ─ ─ ─ ┐ ├ ┘ ─ ─ ─ ─ ┌ ► └ ─ ─ ─ ─ ─ G ─ ─ ─ i ─ ┌ ► └ ─ t ─ ─ ─ ─ H ─ ─ H ─ ─ u ─ ─ u ─ ─ b ─ ─ g ┬ │ │ │ │ ▼ ─ ─ o ─ ─ P ─ ─ ─ ─ a ─ ┐ │ ┘ ─ g ─ ─ e ─ ─ s ─ ─ ─ ┐ │ ┘ Domain Name Provider I use Hover for my domain name provider, but you can use whatever provider you want. You need to delegate the nameservers for your domain to cloudflare\u0026rsquo;s nameservers. Under DNS in your Cloudflare Console you\u0026rsquo;ll see two nameservers assigned to your account. For me they are arnold.ns.cloudflare.com and reza.ns.cloudflare.com.\nCloudflare Now that Cloudflare is acting as the nameserver for your domain, we need to configure it to point to GitHub pages and set up caching rules. You can find more detailed instructions on using a custom domain with GitHub Pages here and here. The second link contains list of IP addresses we need to set up as A records in Cloudflare.\n185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 GitHub Pages GitHub pages works for any repository with it enabled, but there is a special repository for each user called {username}.github.io that GitHub uses for the corresponding URL of the same name. You need a file called CNAME in the root of project that contains the domain name you\u0026rsquo;re pointing towards GitHub. Placing it in the {username}.github.io repository will let you use that custom domain for the GitHub pages of all your other repositories at https://{domain}/{project-name} for example https://dylanj.xyz/julia-webgl.\nHugo To actually generate the site, I decided to go with Hugo which is a very fast static site generator written in Go. You could just as easily use any other static site generator like Next.js if you\u0026rsquo;d prefer to mess around with React instead. I was going for simplicity and being focused on writing content and not writing components which is why I chose Hugo.\nGitHub Actions To automatically deploy our static site to GitHub pages I\u0026rsquo;m using GitHub actions which interact really nicely with GitHub pages.\nIt\u0026rsquo;s as simple as dropping a file in .github/workflows. This is the current GitHub action script used for this blog. name: Build and Deploy on: push: branches: - master jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public ","permalink":"https://dylanj.xyz/posts/how-i-made-this-blog/","summary":"Plan of Attack When evaluating options for starting a blog I wanted something that was fast, free, and easy to setup CI / CD for. GitHub Pages ticks both the free and easy boxes but it can be a bit slow to respond. To solve the speed issue I stuck cloudflare in front of GitHub to leverage its CDN caching, ensuring that response times are fast.\n┌ │ │ │ └ ┌ │ └ ─ ─ ─ ─ ─ d ─ ─ U ─ ─ y ─ ─ s ─ ─ l ─ ─ e ─ ─ G a ─ ─ r ─ ─ i n ─ ─ ─ ─ t r ─ ┐ ├ ┘ ─ H j ─ ─ ─ u o ─ ─ ─ b h ─ ─ ─ n ─ ─ ─ R s ─ ─ ─ e t ─ ┌ │ ► │ └ ─ p o ─ ─ ─ ─ o n ─ ─ C N ─ ─ s .","title":"How I Made This Blog"},{"content":"Works in Progress\nTattoo Roguelike built with Rust + WASM WebGL Julia Fractal NixOS System Configurations VR Fractal Explorer Drag and Drop Workout Builder SplitWise -\u0026gt; YNAB Connector ","permalink":"https://dylanj.xyz/projects/","summary":"Works in Progress\nTattoo Roguelike built with Rust + WASM WebGL Julia Fractal NixOS System Configurations VR Fractal Explorer Drag and Drop Workout Builder SplitWise -\u0026gt; YNAB Connector ","title":"Projects"},{"content":" NixOS and more to come\u0026hellip;\n","permalink":"https://dylanj.xyz/talks/","summary":"NixOS and more to come\u0026hellip;","title":"Talks"}]