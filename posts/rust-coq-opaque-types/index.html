<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Formally Verifying Rust's Opaque Types | dylanj.xyz</title><meta name=keywords content="rust,type theory,formal verification"><meta name=description content="Introduction The other day I was reading this blog post covering existential types in Rust (also known as impl Trait or opaque types). In that blog post, the author makes the following claim.
We‚Äôre going to have to take a slight diversion into type theory here because it motivates a result that is perhaps intuitive. The following proposition holds in intuitionistic logic: ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q)), which means that according to the Curry‚ÄìHoward Correspondence, it also holds when considering the proposition as a type."><meta name=author content="Dylan R. Johnston"><link rel=canonical href=https://dylanj.xyz/posts/rust-coq-opaque-types/><link crossorigin=anonymous href=/assets/css/stylesheet.27661e7c2e89b4bd88bb4232d3b0174c5cb4e0093433f5d5fee5e1fef5dea7f7.css integrity="sha256-J2YefC6JtL2Iu0Iy07AXTFy04Ak0M/XV/uXh/vXep/c=" rel="preload stylesheet" as=style><link crossorigin=anonymous href=/css/extended/syntax.css rel="preload stylesheet" as=style><link rel=icon href=https://dylanj.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dylanj.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dylanj.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://dylanj.xyz/apple-touch-icon.png><link rel=mask-icon href=https://dylanj.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.goat{font-size:.8em!important}code{text-size-adjust:100%;-ms-text-size-adjust:100%;-moz-text-size-adjust:100%;-webkit-text-size-adjust:100%}</style><meta property="og:title" content="Formally Verifying Rust's Opaque Types"><meta property="og:description" content="Introduction The other day I was reading this blog post covering existential types in Rust (also known as impl Trait or opaque types). In that blog post, the author makes the following claim.
We‚Äôre going to have to take a slight diversion into type theory here because it motivates a result that is perhaps intuitive. The following proposition holds in intuitionistic logic: ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q)), which means that according to the Curry‚ÄìHoward Correspondence, it also holds when considering the proposition as a type."><meta property="og:type" content="article"><meta property="og:url" content="https://dylanj.xyz/posts/rust-coq-opaque-types/"><meta property="og:image" content="https://live.staticflickr.com/2069/1989724551_607a6f477b_b.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-01T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://live.staticflickr.com/2069/1989724551_607a6f477b_b.jpg"><meta name=twitter:title content="Formally Verifying Rust's Opaque Types"><meta name=twitter:description content="Introduction The other day I was reading this blog post covering existential types in Rust (also known as impl Trait or opaque types). In that blog post, the author makes the following claim.
We‚Äôre going to have to take a slight diversion into type theory here because it motivates a result that is perhaps intuitive. The following proposition holds in intuitionistic logic: ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q)), which means that according to the Curry‚ÄìHoward Correspondence, it also holds when considering the proposition as a type."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dylanj.xyz/posts/"},{"@type":"ListItem","position":2,"name":"Formally Verifying Rust's Opaque Types","item":"https://dylanj.xyz/posts/rust-coq-opaque-types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Formally Verifying Rust's Opaque Types","name":"Formally Verifying Rust\u0027s Opaque Types","description":"Introduction The other day I was reading this blog post covering existential types in Rust (also known as impl Trait or opaque types). In that blog post, the author makes the following claim.\nWe‚Äôre going to have to take a slight diversion into type theory here because it motivates a result that is perhaps intuitive. The following proposition holds in intuitionistic logic: ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q)), which means that according to the Curry‚ÄìHoward Correspondence, it also holds when considering the proposition as a type.","keywords":["rust","type theory","formal verification"],"articleBody":"Introduction The other day I was reading this blog post covering existential types in Rust (also known as impl Trait or opaque types). In that blog post, the author makes the following claim.\nWe‚Äôre going to have to take a slight diversion into type theory here because it motivates a result that is perhaps intuitive. The following proposition holds in intuitionistic logic: ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q)), which means that according to the Curry‚ÄìHoward Correspondence, it also holds when considering the proposition as a type.\nIn particular the ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q)) caught my eye. While I was working for Originate in San Francisco back in 2017 I used my 20% time project to study Benjamin C. Pierce‚Äôs excellent Software Foundations series which teaches how to structure and formally verify software using the Coq Proof Assistant (yes, it‚Äôs pronounced exactly how you think, üôÑ). It completely changed the way I look at programming for the better but it‚Äôs not a skill that I get to practice regularly and as you get older you have to either use it or lose it. So I thought I‚Äôd try my hand at seeing if I remembered enough of Coq to be able to prove the above statement.\nTrait Dispatch in Rust To understand why we even care about the above proposition, it‚Äôs worth taking a moment to understand how impl Trait is used in Rust, if you‚Äôre not interested in Rust and just want to get to the Coq tutorial you should skip this section and jump head to #Coq\nIn Rust, to abstract over common functionality, we have Traits (interfaces in most other languages). Below is the simple ToString trait from the standard library.\ntrait ToString { fn to_string(\u0026self) -\u003e String; } If we want to write a function that accepts things that can be turned into strings we have a few different options depending on whether we want static or dynamic dispatch. To demonstrate the available options we‚Äôll use a contrived toy function yell which turns the input into a string, convert it to all caps, and prints it to stdout.\nStatic Dispatch fn yell\u003cS: ToString\u003e(stringable: S) { println!(stringable.to_string().to_uppercase()) } In Rust, generics are monomorphised. The compiler will create a copy and unique name for each type the function is called with, meaning each method call on the trait points to one, and only one function so the call can be statically dispatched. For example\nyell(42); yell(\"According to all known laws of aviation ...\"); This will result in the creation of two functions for each call\nfn yell__i32(stringable: i32) { println!(stringable.to_string().to_uppercase()) } fn yell__at_str(stringable: \u0026str) { println!(stringable.to_string().to_uppercase()) } transforming the call site also into their respective monomorphised functions\nyell__i32(42); yell__at_str(\"According to all known laws of aviation ...\"); So when we call the trait method to_string() in each of those monomorphised functions, the rust compiler knows precisely which function call to make and doesn‚Äôt require chasing pointers (dynamic dispatch). It also means the stack layouts of calling those functions can differ but we‚Äôll get into that in a moment when talking about trait objects and object safety (spoilers!).\nDynamic Dispatch Another way to write our yell function is\nfn yell(stringable: \u0026dyn ToString) { println!(stringable.to_string().to_uppercase()) } which from the name of this subsection and the use of the dyn keyword may have tipped you off to the fact it uses dynamic dispatch. If you‚Äôre familiar with how interfaces work in Golang then you already know what‚Äôs going on here.\nIn this case, rust doesn‚Äôt copy the yell method for each type it‚Äôs called with but instead \u0026dyn ToString is often what‚Äôs known as a ‚Äúfat pointer‚Äù. In that, it contains two pointers, one to the data, and one to the vtable for the methods of the trait.\np l o e i n \u0026 n g s t t t e h r r v d t s a a t t b r a l i e n p g o p a i o b n i l t n e e t r e r d s a t e i l o s z i _ v t e g s t r n t a u m r b c e i l t n n e o t g r ( ) It‚Äôs called ‚Äúdynamic dispatch‚Äù because we don‚Äôt know which function we‚Äôre going to call until runtime when we follow the vtable pointer to find the particular to_string() method we‚Äôre going to call. Most of the time the overhead of this pointer chasing doesn‚Äôt matter and your application probably has performance bottlenecks elsewhere, but sometimes every pointer dereference counts.\nObject Safety Beyond questionably legitimate concerns about performance, when you stop to think about how the compiler would layout the stack to call a dynamically dispatched function you may realise a fairly large limitation on what kinds of traits can be dynamically dispatched. They have to be the same size! Or more precisely, the function inputs and outputs must all be of the same size!\nThink about the following trait from the standard library\npub trait Clone { fn clone(\u0026self) -\u003e Self; } What is the amount of space we need to leave on the stack when calling clone()? Well, it returns Self, which is whatever the type that implements clone is, so i32, i64, or String all take up different amounts of space on the stack so it‚Äôs impossible for us to figure out how to layout the stack at compile time when we don‚Äôt know the size of the type until runtime! This is what‚Äôs known in rust as Object Safety. A trait that is not Object Safe contains methods with either its arguments or return values that do not have a constant size across all their possible implementations and therefore it is not safe to turn them into a Trait Object for dynamic dispatch.\nIn addition to trait methods that return Self, trait methods involving generic arguments or return values are also not ‚Äúobject safe‚Äù because the generic methods cannot be monomorphised behind a dynamic dispatch as it brushes up against the halting problem trying to figure how many entries of the monomorphised method are required in the vtable. If you tried to populate the vtable with every possible type in your application for each generic method it would grow enormous!\nimpl Trait So now we understand that sometimes we cannot even use dynamic dispatch even if we don‚Äôt care about the overhead from pointer chasing. We‚Äôre stuck with going back to our static dispatch approach of monomorphising generic functions.\nfn yell\u003cS: ToString\u003e(stringable: S) { println!(stringable.to_string().to_uppercase()) } The additional syntactic and mental overhead of tracking those generic parameters isn‚Äôt so bad with a single generic parameter, but as the number of generic parameters grows, it can become unwieldy. For example, this function is taken from an application I‚Äôm working on that connects several different financial applications and follows the Ports and Adapters (also known as Clean or Hexagonal architecture) pattern of hiding concrete side effects behind simple interfaces and injecting them as needed.\npub fn process\u003cE, B, S\u003e( config: transformer::Config, expense_tracker: E, budget: B, state: S, ) -\u003e Result\u003c()\u003e where E: ExpenseTracker, B: Budget, S: State, { ... } I don‚Äôt know about you, but I find that kind of hard to read, especially since we‚Äôre introducing generic parameters, E, B, and S and only at the end of the function definition are we giving them proper constraints. Luckily Rust has an answer! impl Trait. We can instead rewrite the above function as.\npub fn process( config: transformer::Config, expense_tracker: impl ExpenseTracker, budget: impl Budget, state: impl State, ) -\u003e Result\u003c()\u003e With this in mind you might be asking yourself why would you ever using dynamic dispatch over static. The main reason is when the dispatch is well, dynamic! Such as when you have a collection of trait objects.\nfn example() { let string = \"hello\"; let integer = 3 as i32; let collection: Vec\u003c\u0026dyn ToString\u003e = vec![\u0026string, \u0026integer]; } Comparatively it is not possible to create a collection using impl Trait, nor is it possible to express this with generic constraints because the underlying opaque but concrete types are of different sizes.\nfn first() -\u003e impl ToString { \"According to all known laws of aviation ...\" } fn second() -\u003e impl ToString { 42 } fn example() { vec![first(), second()]; // Error ^^^ // mismatched types // expected opaque type `impl ToString` (opaque type at ) // found opaque type `impl ToString` (opaque type at ) // distinct uses of `impl Trait` result in different opaque types } But how to understand what impl Trait means? One way to understand it is it‚Äôs saying that there exists a type (unnamed) that implements the trait, the fact that it‚Äôs unnamed is why impl Trait is often referred to as opaque types, or existential types. We‚Äôre taking for granted that a type, some type, exists that satisfies this trait, but is it always safe to take the prior generic function and transform it into the existential form and vice versa? The introductory paragraph claims that it always is ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q)), but let‚Äôs not take some guy‚Äôs word for it, we can do better! Let‚Äôs prove it!\nCoq The Coq toolchain is a bit tricky to set up locally, but luckily we don‚Äôt have to as there‚Äôs an excellent online IDE that we can use instead. I‚Äôd highly recommend following along this next section using that or another Coq IDE instead of just trying to understand it by reading. To translate our theorem into a form that Coq understands we can write\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. First, let‚Äôs take a second to understand our proposed theorem.\nforall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). The first part, forall (Trait: Type -\u003e Prop) (Result: Prop) is saying that what we want to prove should be true for every possible Trait, and any possible return value, we can‚Äôt rely on anything true about any particular trait, our results are universal.\nThe rest of our theorem is then broken into two halves separated by \u003c-\u003e. This is known as material equivalence, or ‚Äúif and only if‚Äù, which is to say the left is true, if and only if the right is true, and visa versa. Therefore to prove it, we have to prove that the left proposition implies the right proposition, and also prove that the right proposition implies the left proposition. So we started trying to prove one thing, and now we have to prove two things! This process is very common in formal verification. To prove your goal, you have to break it apart and prove sub-sections of it. To prove the A \u0026 B you have to prove A, and you have to prove B, to prove A | B you can take your pick of A or B whichever you think is easier to prove.\nSo now we have to prove\n- (exists t, Trait(t)) -\u003e Result) -\u003e (forall t, (Trait(t) -\u003e Result) - (forall t, (Trait(t) -\u003e Result) -\u003e (exists t, Trait(t)) -\u003e Result) tactic split A transformation in Coq is called a Tactic. The tactic for splitting our goal into two separate goals like this is unsurprisingly called split. To evaluate your proof up to where your cursor is press CMD+Enter. You should see the goals screen on the right update to reflect the new state of trying to prove our theorem.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. Should give the output in the goals panel of\n2 goals Trait : Type -\u003e Prop Result : Prop ------------------------ (exists t : Type, Trait t) -\u003e Result) -\u003e forall t : Type, Trait t -\u003e Result subgoal 2 is: (forall t : Type, Trait t -\u003e Result) -\u003e (exists t : Type, Trait t) -\u003e Result First Goal To focus on one goal at a time we use - to denote each branch of the proof. We‚Äôll use it to focus on the first part of our proof.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - Tactic intros 1 goal Trait: Type -\u003e Prop Result: Prop ------------------------ ((exists t : Type , Trait t) -\u003e Result) -\u003e forall t : Type , Trait t -\u003e Result The way to understand trying to prove an implication like A -\u003e B -\u003e C, is that we get to assume, A, and B, when trying to prove C. So with the above goal, we get to assume we already have the two antecedent terms ((exists t : Type , Trait t) -\u003e Result) and forall t : Type , Trait t. The tactic that lets us do this is called intro for one variable at a time, or intros if you want to ‚Äúintroduce‚Äù multiple at the same time. Naming these implied assumptions is hard so feel free to name them however you want or leave it blank and let Coq auto name them.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - intros existsTrait type trait. Tactic apply 1 goal Trait : Type -\u003e Prop Result : Prop existsTrait : (exists t : Type, Trait t) -\u003e Result type : Type trait : Trait type ------------------------ Result Implications work the opposite way when they‚Äôre in our assumptions. Right now our goal is to make a Result, in our assumptions we have an implication existsTrait : (exists t : Type, Trait t) -\u003e Result which can give us a Result if we‚Äôre able to prove its antecedent. So by ‚Äúapplying‚Äù our assumption, we can shift our goal to trying to prove the assumptions antecedent. Maybe it‚Äôs a dead end and we‚Äôll have to backtrack, but Result doesn‚Äôt appear anywhere else in our assumptions so it‚Äôs worth a try. The tactic to do this is unsurprisingly called apply.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - intros existsTrait type trait. apply existsTrait. Tactic exists 1 goal Trait : Type -\u003e Prop Result : Prop existsTrait : (exists t : Type, Trait t) -\u003e Result type : Type trait : Trait type ------------------------ exists t : Type, Trait t Now our goal is exists t : Type, Trait t, much like forall and intros, there exists a tactic for dealing with existentially quantified variables, called exists. Although unlike intros, which give us new assumptions, exists demands that we prove that a term exists. It is in some sense the opposite of forall/intros, it consumes a term rather than giving us one. Luckily, after examining our assumptions, we can see that our previous intros gave us an assumption of kind type : Type that matches the kind demanded by the ‚Äúexists‚Äù. So we can get rid of it with exists.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - intros existsTrait type trait. apply existsTrait. exists type. Tactic assumption 1 goal Trait : Type -\u003e Prop Result : Prop exists : Trait(exists t : Type, Trait t) -\u003e Result type : Type trait : Trait type ------------------------ Trait type Now you may notice that our goal exactly matches one of our assumptions. So we can use the tactic assumption to finish this branch of the proof! One down and one to go!\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - intros existsTrait type trait. apply existsTrait. exists type. assumption. - Second Goal 1 goal Trait : Type -\u003e Prop Result : Prop ------------------------ (forall t : Type, Trait t -\u003e Result) -\u003e (exists t : Type, Trait t) -\u003e Result Now we‚Äôre proving that the material equivalence holds in the other direction, and just like the first branch we use intros to move the left-hand side of the implications into our assumptions.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. Tactic destruct 1 goal Trait : Type -\u003e Prop Result : Prop anyTrait : forall t : Type , Trait t -\u003e Result existsTrait : exists t : Type, Trait t ------------------------ Result At this point you might be tempted to try and apply anyTrait just like we did for our first goal, trying to switch the goal from result to forall t : Type , Trait t, however, this doesn‚Äôt work with Coq complaining that Unable to find an instance for the variable t. This is because t is still universally quantified right now, whereas in our first goal t was existentially quantified. So we‚Äôre going to need to find ourselves a t: Type before we can shift our goal.\nWe also have the existsTrait: exists t : Type, Trait t assumption. Luckily, when we have a term like this, we can ask Coq if this expression implies anything else that is not currently in our assumptions. We do this with the inversion or destruct tactics. Coq will auto-name the new assumptions but we can also give them meaningful names with as.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. destruct existsTrait as (t, trait). Tactic apply _ with _ Trait : Type -\u003e Prop Result : Prop anyTrait : forall t : Type, Trait t -\u003e Result t : Type trait : Trait type ------------------------ Result Coq has broken apart existsTrait into its two assumptions. So now we have an assumption of kind Type! We can now solve the problem we had before about applying anyTrait.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. destruct existsTrait as (t, trait). apply anyTrait with t. Tactic assumption Trait : Type -\u003e Prop Result : Prop anyTrait : forall t : Type, Trait t -\u003e Result t : Type trait : Trait t ------------------------ Trait t Now just like before, our goal matches one of our assumptions, so we can finish up this branch with assumption.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. destruct existsTrait as (t, trait). apply anyTrait with t. assumption. QED No more goals. Now that we‚Äôve proved all of our goals, we get to do the best thing about formal verification. The sweet three-letter acronym. QED.\nTheorem impl_trait_transform: forall (Trait: Type -\u003e Prop) (Result: Prop), ((exists t, Trait(t)) -\u003e Result) \u003c-\u003e (forall t, (Trait(t) -\u003e Result)). Proof. split. - intros existsTrait type concreteTrait. apply existsTrait. exists type. assumption. - intros anyTrait existsTrait. destruct existsTrait as (t, trait). apply anyTrait with t. assumption. Qed. Conclusion And there you go, we‚Äôve formally verified that our transformation from generic arguments with trait bounds into existential impl Trait arguments is always valid. Of course, Rust would not have implemented the feature had it not made sense, but I think it‚Äôs gratifying to be able to prove such a cryptic statement like ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q))\nHopefully, this has given you a bit of a taste of how to reason when it comes to formally verifying programs which is such an interesting but alien style of programming. It feels like playing with Legos where the bricks are parts of your program. You know the final shape you want, you just have to keep exploring how they combine to get there. There is a deep connection between theorem proving and metaprogramming but that‚Äôs a story for another time.\nIf you‚Äôd like to explore more formal verification I‚Äôd highly recommend checking out Software Foundations or Edwin Brady‚Äôs Type-Driven Development with Idris.\n","wordCount":"3454","inLanguage":"en","image":"https://live.staticflickr.com/2069/1989724551_607a6f477b_b.jpg","datePublished":"2022-08-01T00:00:00Z","dateModified":"2022-08-01T00:00:00Z","author":{"@type":"Person","name":"Dylan R. Johnston"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dylanj.xyz/posts/rust-coq-opaque-types/"},"publisher":{"@type":"Organization","name":"dylanj.xyz","logo":{"@type":"ImageObject","url":"https://dylanj.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dylanj.xyz/ accesskey=h title="dylanj.xyz (Alt + H)">dylanj.xyz</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dylanj.xyz/archives title=Archives><span>Archives</span></a></li><li><a href=https://dylanj.xyz/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://dylanj.xyz/tags title=Tags><span>Tags</span></a></li><li><a href=https://dylanj.xyz/projects/ title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dylanj.xyz/>Home</a>&nbsp;¬ª&nbsp;<a href=https://dylanj.xyz/posts/>Posts</a></div><h1 class=post-title>Formally Verifying Rust's Opaque Types</h1><div class=post-meta><span title='2022-08-01 00:00:00 +0000 UTC'>August 1, 2022</span>&nbsp;¬∑&nbsp;17 min&nbsp;¬∑&nbsp;Dylan R. Johnston&nbsp;|&nbsp;<a href=https://github.com/dylanrjohnston/dylanrjohnston.github.io/tree/master/content/posts/rust-coq-opaque-types.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://live.staticflickr.com/2069/1989724551_607a6f477b_b.jpg alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#trait-dispatch-in-rust aria-label="Trait Dispatch in Rust">Trait Dispatch in Rust</a><ul><li><a href=#static-dispatch aria-label="Static Dispatch">Static Dispatch</a></li><li><a href=#dynamic-dispatch aria-label="Dynamic Dispatch">Dynamic Dispatch</a></li><li><a href=#object-safety aria-label="Object Safety">Object Safety</a></li><li><a href=#impl-trait aria-label="impl Trait"><code>impl Trait</code></a></li></ul></li><li><a href=#coq aria-label=Coq>Coq</a><ul><ul><li><a href=#tactic-split aria-label="tactic split">tactic <code>split</code></a></li><li><a href=#first-goal aria-label="First Goal">First Goal</a></li><li><a href=#tactic-intros aria-label="Tactic intros">Tactic <code>intros</code></a></li><li><a href=#tactic-apply aria-label="Tactic apply">Tactic <code>apply</code></a></li><li><a href=#tactic-exists aria-label="Tactic exists">Tactic <code>exists</code></a></li><li><a href=#tactic-assumption aria-label="Tactic assumption">Tactic <code>assumption</code></a></li><li><a href=#second-goal aria-label="Second Goal">Second Goal</a></li><li><a href=#tactic-destruct aria-label="Tactic destruct">Tactic <code>destruct</code></a></li><li><a href=#tactic-apply-_-with-_ aria-label="Tactic apply _ with _">Tactic <code>apply _ with _</code></a></li><li><a href=#tactic-assumption-1 aria-label="Tactic assumption">Tactic <code>assumption</code></a></li><li><a href=#qed aria-label=QED>QED</a></li></ul></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>The other day I was reading <a href=https://varkor.github.io/blog/2018/07/03/existential-types-in-rust.html>this blog post</a> covering existential types in Rust (also known as <code>impl Trait</code> or opaque types). In that blog post, the author makes the following claim.</p><blockquote><p>We‚Äôre going to have to take a slight diversion into type theory here because it motivates a result that is perhaps intuitive. The following proposition holds in intuitionistic logic: ((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q)), which means that according to the Curry‚ÄìHoward Correspondence, it also holds when considering the proposition as a type.</p></blockquote><p>In particular the <code>((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q))</code> caught my eye. While I was working for <a href=https://www.originate.com/>Originate</a> in San Francisco back in 2017 I used my 20% time project to study Benjamin C. Pierce&rsquo;s excellent <a href=https://softwarefoundations.cis.upenn.edu/>Software Foundations</a> series which teaches how to structure and formally verify software using the Coq Proof Assistant <a href=https://www.theregister.com/2021/06/15/coq_programming_language_change/>(yes, it&rsquo;s pronounced exactly how you think, üôÑ)</a>. It completely changed the way I look at programming for the better but it&rsquo;s not a skill that I get to practice regularly and as you get older you have to either use it or lose it. So I thought I&rsquo;d try my hand at seeing if I remembered enough of Coq to be able to prove the above statement.</p><h1 id=trait-dispatch-in-rust>Trait Dispatch in Rust<a hidden class=anchor aria-hidden=true href=#trait-dispatch-in-rust>#</a></h1><p>To understand why we even care about the above proposition, it&rsquo;s worth taking a moment to understand how <code>impl Trait</code> is used in Rust, if you&rsquo;re not interested in Rust and just want to get to the Coq tutorial you should skip this section and jump head to <a href=#coq>#Coq</a></p><p>In Rust, to abstract over common functionality, we have Traits (interfaces in most other languages). Below is the simple <code>ToString</code> trait from the standard library.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=nb>ToString</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>fn</span> <span class=nf>to_string</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>If we want to write a function that accepts things that can be turned into strings we have a few different options depending on whether we want static or dynamic dispatch. To demonstrate the available options we&rsquo;ll use a contrived toy function <code>yell</code> which turns the input into a string, convert it to all caps, and prints it to stdout.</p><h2 id=static-dispatch>Static Dispatch<a hidden class=anchor aria-hidden=true href=#static-dispatch>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>yell</span><span class=o>&lt;</span><span class=n>S</span>: <span class=nb>ToString</span><span class=o>&gt;</span><span class=p>(</span><span class=n>stringable</span>: <span class=nc>S</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=n>stringable</span><span class=p>.</span><span class=n>to_string</span><span class=p>().</span><span class=n>to_uppercase</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>In Rust, generics are monomorphised. The compiler will create a copy and unique name for each type the function is called with, meaning each method call on the trait points to one, and only one function so the call can be statically dispatched. For example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>yell</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>yell</span><span class=p>(</span><span class=s>&#34;According to all known laws of aviation ...&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>This will result in the creation of two functions for each call</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>yell__i32</span><span class=p>(</span><span class=n>stringable</span>: <span class=kt>i32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=n>stringable</span><span class=p>.</span><span class=n>to_string</span><span class=p>().</span><span class=n>to_uppercase</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>yell__at_str</span><span class=p>(</span><span class=n>stringable</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=n>stringable</span><span class=p>.</span><span class=n>to_string</span><span class=p>().</span><span class=n>to_uppercase</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>transforming the call site also into their respective monomorphised functions</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>yell__i32</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>yell__at_str</span><span class=p>(</span><span class=s>&#34;According to all known laws of aviation ...&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>So when we call the trait method <code>to_string()</code> in each of those monomorphised functions, the rust compiler knows precisely which function call to make and doesn&rsquo;t require chasing pointers (dynamic dispatch). It also means the stack layouts of calling those functions can differ but we&rsquo;ll get into that in a moment when talking about trait objects and object safety (spoilers!).</p><h2 id=dynamic-dispatch>Dynamic Dispatch<a hidden class=anchor aria-hidden=true href=#dynamic-dispatch>#</a></h2><p>Another way to write our yell function is</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>yell</span><span class=p>(</span><span class=n>stringable</span>: <span class=kp>&amp;</span><span class=nc>dyn</span><span class=w> </span><span class=nb>ToString</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=n>stringable</span><span class=p>.</span><span class=n>to_string</span><span class=p>().</span><span class=n>to_uppercase</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>which from the name of this subsection and the use of the <code>dyn</code> keyword may have tipped you off to the fact it uses dynamic dispatch. If you&rsquo;re familiar with how interfaces work in Golang then you already know what&rsquo;s going on here.</p><p>In this case, rust doesn&rsquo;t copy the yell method for each type it&rsquo;s called with but instead <code>&dyn ToString</code> is often what&rsquo;s known as a &ldquo;fat pointer&rdquo;. In that, it contains two pointers, one to the data, and one to the vtable for the methods of the trait.</p><div class="goat svg-container"><svg xmlns="http://www.w3.org/2000/svg" font-family="Menlo,Lucida Console,monospace" viewBox="0 0 368 265"><g transform="translate(8,16)"><path d="M96 16H232" fill="none" stroke="currentcolor"/><path d="M40 32H96" fill="none" stroke="currentcolor"/><path d="M96 48H232" fill="none" stroke="currentcolor"/><path d="M232 64h64" fill="none" stroke="currentcolor"/><path d="M96 80H232" fill="none" stroke="currentcolor"/><path d="M0 96H32" fill="none" stroke="currentcolor"/><path d="M48 96H80" fill="none" stroke="currentcolor"/><path d="M248 96h40" fill="none" stroke="currentcolor"/><path d="M304 96h48" fill="none" stroke="currentcolor"/><path d="M0 128H80" fill="none" stroke="currentcolor"/><path d="M248 128H352" fill="none" stroke="currentcolor"/><path d="M0 160H80" fill="none" stroke="currentcolor"/><path d="M248 160H352" fill="none" stroke="currentcolor"/><path d="M248 192H352" fill="none" stroke="currentcolor"/><path d="M248 224H352" fill="none" stroke="currentcolor"/><path d="M0 96v32" fill="none" stroke="currentcolor"/><path d="M0 128v32" fill="none" stroke="currentcolor"/><path d="M40 32V96" fill="none" stroke="currentcolor"/><path d="M80 96v32" fill="none" stroke="currentcolor"/><path d="M80 128v32" fill="none" stroke="currentcolor"/><path d="M96 16V32" fill="none" stroke="currentcolor"/><path d="M96 32V48" fill="none" stroke="currentcolor"/><path d="M96 48V80" fill="none" stroke="currentcolor"/><path d="M232 16V48" fill="none" stroke="currentcolor"/><path d="M232 48V64" fill="none" stroke="currentcolor"/><path d="M232 64V80" fill="none" stroke="currentcolor"/><path d="M248 96v32" fill="none" stroke="currentcolor"/><path d="M248 128v32" fill="none" stroke="currentcolor"/><path d="M248 160v32" fill="none" stroke="currentcolor"/><path d="M248 192v32" fill="none" stroke="currentcolor"/><path d="M296 64V96" fill="none" stroke="currentcolor"/><path d="M352 96v32" fill="none" stroke="currentcolor"/><path d="M352 128v32" fill="none" stroke="currentcolor"/><path d="M352 160v32" fill="none" stroke="currentcolor"/><path d="M352 192v32" fill="none" stroke="currentcolor"/><polygon points="48.000000,96.000000 36.000000,90.400002 36.000000,101.599998" fill="currentcolor" transform="rotate(90.000000, 40.000000, 96.000000)"/><polygon points="304.000000,96.000000 292.000000,90.400002 292.000000,101.599998" fill="currentcolor" transform="rotate(90.000000, 296.000000, 96.000000)"/><text text-anchor="middle" x="16" y="116" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="16" y="148" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="24" y="116" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="24" y="148" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="32" y="116" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="32" y="148" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="32" y="180" fill="currentcolor" style="font-size:1em">&amp;</text><text text-anchor="middle" x="40" y="116" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="40" y="148" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="40" y="180" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="48" y="116" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="48" y="148" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="48" y="180" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="56" y="116" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="56" y="148" fill="currentcolor" style="font-size:1em">h</text><text text-anchor="middle" x="56" y="180" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="64" y="116" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="112" y="68" fill="currentcolor" style="font-size:1em">v</text><text text-anchor="middle" x="120" y="36" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="120" y="68" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="128" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="128" y="68" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="136" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="136" y="68" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="144" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="144" y="68" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="152" y="68" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="160" y="36" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="168" y="36" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="168" y="68" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="176" y="36" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="176" y="68" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="184" y="36" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="184" y="68" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="192" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="192" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="192" y="68" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="200" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="200" y="36" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="200" y="68" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="208" y="36" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="208" y="68" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="216" y="68" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="264" y="116" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="264" y="148" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="264" y="180" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="264" y="212" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="272" y="116" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="272" y="148" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="272" y="180" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="272" y="212" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="280" y="116" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="280" y="148" fill="currentcolor" style="font-size:1em">z</text><text text-anchor="middle" x="280" y="180" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="280" y="212" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="280" y="244" fill="currentcolor" style="font-size:1em">v</text><text text-anchor="middle" x="288" y="116" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="288" y="148" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="288" y="180" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="288" y="212" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="288" y="244" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="296" y="116" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="296" y="180" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="296" y="212" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="296" y="244" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="304" y="116" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="304" y="180" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="304" y="212" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="304" y="244" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="312" y="116" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="312" y="180" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="312" y="212" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="312" y="244" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="320" y="116" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="320" y="180" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="320" y="212" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="320" y="244" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="328" y="116" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="328" y="180" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="328" y="212" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="336" y="116" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="336" y="212" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="344" y="212" fill="currentcolor" style="font-size:1em">)</text></g></svg></div><p>It&rsquo;s called &ldquo;dynamic dispatch&rdquo; because we don&rsquo;t know which function we&rsquo;re going to call until runtime when we follow the vtable pointer to find the particular <code>to_string()</code> method we&rsquo;re going to call. Most of the time the overhead of this pointer chasing doesn&rsquo;t matter and your application probably has performance bottlenecks elsewhere, but sometimes every pointer dereference counts.</p><h2 id=object-safety>Object Safety<a hidden class=anchor aria-hidden=true href=#object-safety>#</a></h2><p>Beyond questionably legitimate concerns about performance, when you stop to think about how the compiler would layout the stack to call a dynamically dispatched function you may realise a fairly large limitation on what kinds of traits can be dynamically dispatched. <strong>They have to be the same size!</strong> Or more precisely, the function inputs and outputs must all be of the same size!</p><p>Think about the following trait from the standard library</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>Clone</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>What is the amount of space we need to leave on the stack when calling <code>clone()</code>? Well, it returns Self, which is whatever the type that implements clone is, so i32, i64, or String all take up different amounts of space on the stack so it&rsquo;s impossible for us to figure out how to layout the stack at compile time when we don&rsquo;t know the size of the type until runtime! This is what&rsquo;s known in rust as <strong>Object Safety</strong>. A trait that is <strong>not</strong> Object Safe contains methods with either its arguments or return values that do not have a constant size across all their possible implementations and therefore it is not safe to turn them into a <strong>Trait Object</strong> for dynamic dispatch.</p><p>In addition to trait methods that return Self, trait methods involving generic arguments or return values are also not &ldquo;object safe&rdquo; because the generic methods cannot be monomorphised behind a dynamic dispatch as it brushes up against the halting problem trying to figure how many entries of the monomorphised method are required in the vtable. If you tried to populate the vtable with every possible type in your application for each generic method it would grow enormous!</p><h2 id=impl-trait><code>impl Trait</code><a hidden class=anchor aria-hidden=true href=#impl-trait>#</a></h2><p>So now we understand that sometimes we cannot even use dynamic dispatch even if we don&rsquo;t care about the overhead from pointer chasing. We&rsquo;re stuck with going back to our static dispatch approach of monomorphising generic functions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>yell</span><span class=o>&lt;</span><span class=n>S</span>: <span class=nb>ToString</span><span class=o>&gt;</span><span class=p>(</span><span class=n>stringable</span>: <span class=nc>S</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=fm>println!</span><span class=p>(</span><span class=n>stringable</span><span class=p>.</span><span class=n>to_string</span><span class=p>().</span><span class=n>to_uppercase</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The additional syntactic and mental overhead of tracking those generic parameters isn&rsquo;t so bad with a single generic parameter, but as the number of generic parameters grows, it can become unwieldy. For example, this function is taken from an application I&rsquo;m working on that connects several different financial applications and follows the Ports and Adapters (also known as Clean or Hexagonal architecture) pattern of hiding concrete side effects behind simple interfaces and injecting them as needed.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>process</span><span class=o>&lt;</span><span class=n>E</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>S</span><span class=o>&gt;</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>config</span>: <span class=nc>transformer</span>::<span class=n>Config</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>expense_tracker</span>: <span class=nc>E</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>budget</span>: <span class=nc>B</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>state</span>: <span class=nc>S</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>E</span>: <span class=nc>ExpenseTracker</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>B</span>: <span class=nc>Budget</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>S</span>: <span class=nc>State</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>{</span><span class=w> </span><span class=o>..</span><span class=p>.</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>I don&rsquo;t know about you, but I find that kind of hard to read, especially since we&rsquo;re introducing generic parameters, E, B, and S and only at the end of the function definition are we giving them proper constraints. Luckily Rust has an answer! <code>impl Trait</code>. We can instead rewrite the above function as.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>process</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>config</span>: <span class=nc>transformer</span>::<span class=n>Config</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>expense_tracker</span>: <span class=nc>impl</span><span class=w> </span><span class=n>ExpenseTracker</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>budget</span>: <span class=nc>impl</span><span class=w> </span><span class=n>Budget</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>state</span>: <span class=nc>impl</span><span class=w> </span><span class=n>State</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w>
</span></span></span></code></pre></div><p>With this in mind you might be asking yourself why would you ever using dynamic dispatch over static. The main reason is when the dispatch is well, dynamic! Such as when you have a collection of trait objects.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>example</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>string</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;hello&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>integer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>i32</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>collection</span>: <span class=nb>Vec</span><span class=o>&lt;&amp;</span><span class=k>dyn</span><span class=w> </span><span class=nb>ToString</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[</span><span class=o>&amp;</span><span class=n>string</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>integer</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Comparatively it is not possible to create a collection using <code>impl Trait</code>, nor is it possible to express this with generic constraints because the underlying opaque but concrete types are of different sizes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>first</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>ToString</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=s>&#34;According to all known laws of aviation ...&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>second</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>ToString</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=mi>42</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>example</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>vec!</span><span class=p>[</span><span class=n>first</span><span class=p>(),</span><span class=w> </span><span class=n>second</span><span class=p>()];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//      Error ^^^
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// mismatched types
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// expected opaque type `impl ToString` (opaque type at &lt;src/main.rs:1:15&gt;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// found opaque type `impl ToString` (opaque type at &lt;src/main.rs:4:16&gt;)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// distinct uses of `impl Trait` result in different opaque types
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>But how to understand what <code>impl Trait</code> means? One way to understand it is it&rsquo;s saying that there exists a type (unnamed) that implements the trait, the fact that it&rsquo;s unnamed is why <code>impl Trait</code> is often referred to as <strong>opaque types</strong>, or <strong>existential types</strong>. We&rsquo;re taking for granted that a type, some type, exists that satisfies this trait, but is it always safe to take the prior generic function and transform it into the existential form and vice versa? The introductory paragraph claims that it always is <code>((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q))</code>, but let&rsquo;s not take some guy&rsquo;s word for it, we can do better! Let&rsquo;s prove it!</p><h1 id=coq>Coq<a hidden class=anchor aria-hidden=true href=#coq>#</a></h1><p>The Coq toolchain is a bit tricky to set up locally, but luckily we don&rsquo;t have to as there&rsquo;s an excellent <a href=https://coq.vercel.app/scratchpad.html>online IDE</a> that we can use instead. I&rsquo;d highly recommend following along this next section using that or another Coq IDE instead of just trying to understand it by reading. To translate our theorem into a form that Coq understands we can write</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span></code></pre></div><p>First, let&rsquo;s take a second to understand our proposed theorem.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span></code></pre></div><p>The first part, <code>forall (Trait: Type -> Prop) (Result: Prop)</code> is saying that what we want to prove should be true for every possible Trait, and any possible return value, we can&rsquo;t rely on anything true about any particular trait, our results are universal.</p><p>The rest of our theorem is then broken into two halves separated by <code>&lt;-></code>. This is known as <a href=https://en.wikipedia.org/wiki/If_and_only_if>material equivalence</a>, or &ldquo;if and only if&rdquo;, which is to say the left is true, if and only if the right is true, and visa versa. Therefore to prove it, we have to prove that the left proposition implies the right proposition, and also prove that the right proposition implies the left proposition. So we started trying to prove one thing, and now we have to prove two things! This process is very common in formal verification. To prove your goal, you have to break it apart and prove sub-sections of it. To prove the <code>A & B</code> you have to prove <code>A</code>, and you have to prove <code>B</code>, to prove <code>A | B</code> you can take your pick of <code>A</code> or <code>B</code> whichever you think is easier to prove.</p><p>So now we have to prove</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=o>-</span> <span class=o>(</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=o>-</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span>
</span></span></code></pre></div><h3 id=tactic-split>tactic <code>split</code><a hidden class=anchor aria-hidden=true href=#tactic-split>#</a></h3><p>A transformation in Coq is called a Tactic. The tactic for splitting our goal into two separate goals like this is unsurprisingly called <code>split</code>. To evaluate your proof up to where your cursor is press <code>CMD+Enter</code>. You should see the goals screen on the right update to reflect the new state of trying to prove our theorem.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span></code></pre></div><p>Should give the output in the goals panel of</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>2</span> <span class=n>goals</span>
</span></span><span class=line><span class=cl>  <span class=n>Trait</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl>  <span class=n>Result</span> <span class=o>:</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=o>------------------------</span>
</span></span><span class=line><span class=cl><span class=o>(</span><span class=k>exists</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=k>forall</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>subgoal</span> <span class=n>2</span> <span class=k>is</span><span class=o>:</span>
</span></span><span class=line><span class=cl><span class=o>(</span><span class=k>forall</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=k>exists</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span></code></pre></div><h3 id=first-goal>First Goal<a hidden class=anchor aria-hidden=true href=#first-goal>#</a></h3><p>To focus on one goal at a time we use <code>-</code> to denote each branch of the proof. We&rsquo;ll use it to focus on the first part of our proof.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span>
</span></span></code></pre></div><h3 id=tactic-intros>Tactic <code>intros</code><a hidden class=anchor aria-hidden=true href=#tactic-intros>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>1</span> <span class=n>goal</span>
</span></span><span class=line><span class=cl><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=o>------------------------</span>
</span></span><span class=line><span class=cl><span class=o>((</span><span class=k>exists</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span><span class=o>)</span>  <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=k>forall</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span></code></pre></div><p>The way to understand trying to prove an implication like <code>A -> B -> C</code>, is that we get to assume, <code>A</code>, and <code>B</code>, when trying to prove <code>C</code>. So with the above goal, we get to assume we already have the two antecedent terms <code>((exists t : Type , Trait t) -> Result)</code> and <code>forall t : Type , Trait t</code>. The tactic that lets us do this is called <code>intro</code> for one variable at a time, or <code>intros</code> if you want to &ldquo;introduce&rdquo; multiple at the same time. Naming these implied assumptions is hard so feel free to name them however you want or leave it blank and let Coq auto name them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>existsTrait</span> <span class=n>type</span> <span class=n>trait</span><span class=o>.</span>
</span></span></code></pre></div><h3 id=tactic-apply>Tactic <code>apply</code><a hidden class=anchor aria-hidden=true href=#tactic-apply>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>1</span> <span class=n>goal</span>
</span></span><span class=line><span class=cl><span class=n>Trait</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>Result</span> <span class=o>:</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>existsTrait</span> <span class=o>:</span> <span class=o>(</span><span class=k>exists</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span><span class=line><span class=cl><span class=n>type</span> <span class=o>:</span> <span class=kt>Type</span>
</span></span><span class=line><span class=cl><span class=n>trait</span> <span class=o>:</span> <span class=n>Trait</span> <span class=n>type</span>
</span></span><span class=line><span class=cl><span class=o>------------------------</span>
</span></span><span class=line><span class=cl><span class=n>Result</span>
</span></span></code></pre></div><p>Implications work the opposite way when they&rsquo;re in our assumptions. Right now our goal is to make a <code>Result</code>, in our assumptions we have an implication <code>existsTrait : (exists t : Type, Trait t) -> Result</code> which can give us a <code>Result</code> if we&rsquo;re able to prove its antecedent. So by &ldquo;applying&rdquo; our assumption, we can shift our goal to trying to prove the assumptions antecedent. Maybe it&rsquo;s a dead end and we&rsquo;ll have to backtrack, but <code>Result</code> doesn&rsquo;t appear anywhere else in our assumptions so it&rsquo;s worth a try. The tactic to do this is unsurprisingly called <strong>apply</strong>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>existsTrait</span> <span class=n>type</span> <span class=n>trait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span></code></pre></div><h3 id=tactic-exists>Tactic <code>exists</code><a hidden class=anchor aria-hidden=true href=#tactic-exists>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>1</span> <span class=n>goal</span>
</span></span><span class=line><span class=cl><span class=n>Trait</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>Result</span> <span class=o>:</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>existsTrait</span> <span class=o>:</span> <span class=o>(</span><span class=k>exists</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span><span class=line><span class=cl><span class=n>type</span> <span class=o>:</span> <span class=kt>Type</span>
</span></span><span class=line><span class=cl><span class=n>trait</span> <span class=o>:</span> <span class=n>Trait</span> <span class=n>type</span>
</span></span><span class=line><span class=cl><span class=o>------------------------</span>
</span></span><span class=line><span class=cl><span class=k>exists</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span>
</span></span></code></pre></div><p>Now our goal is <code>exists t : Type, Trait t</code>, much like <code>forall</code> and <code>intros</code>, there exists a tactic for dealing with existentially quantified variables, called <code>exists</code>. Although unlike intros, which give us new assumptions, <code>exists</code> demands that we prove that a term exists. It is in some sense the opposite of <code>forall/intros</code>, it consumes a term rather than giving us one. Luckily, after examining our assumptions, we can see that our previous <code>intros</code> gave us an assumption of kind <code>type : Type</code> that matches the kind demanded by the &ldquo;exists&rdquo;. So we can get rid of it with <code>exists</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>existsTrait</span> <span class=n>type</span> <span class=n>trait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>exists</span> <span class=n>type</span><span class=o>.</span>
</span></span></code></pre></div><h3 id=tactic-assumption>Tactic <code>assumption</code><a hidden class=anchor aria-hidden=true href=#tactic-assumption>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>1</span> <span class=n>goal</span>
</span></span><span class=line><span class=cl><span class=n>Trait</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>Result</span> <span class=o>:</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=k>exists</span> <span class=o>:</span> <span class=n>Trait</span><span class=o>(</span><span class=k>exists</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span><span class=line><span class=cl><span class=n>type</span> <span class=o>:</span> <span class=kt>Type</span>
</span></span><span class=line><span class=cl><span class=n>trait</span> <span class=o>:</span> <span class=n>Trait</span> <span class=n>type</span>
</span></span><span class=line><span class=cl><span class=o>------------------------</span>
</span></span><span class=line><span class=cl><span class=n>Trait</span> <span class=n>type</span>
</span></span></code></pre></div><p>Now you may notice that our goal exactly matches one of our assumptions. So we can use the tactic <code>assumption</code> to finish this branch of the proof! One down and one to go!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>existsTrait</span> <span class=n>type</span> <span class=n>trait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>exists</span> <span class=n>type</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=kp>assumption</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span>
</span></span></code></pre></div><h3 id=second-goal>Second Goal<a hidden class=anchor aria-hidden=true href=#second-goal>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>1</span> <span class=n>goal</span>
</span></span><span class=line><span class=cl><span class=n>Trait</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>Result</span> <span class=o>:</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=o>------------------------</span>
</span></span><span class=line><span class=cl><span class=o>(</span><span class=k>forall</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=k>exists</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span></code></pre></div><p>Now we&rsquo;re proving that the material equivalence holds in the other direction, and just like the first branch we use <code>intros</code> to move the left-hand side of the implications into our assumptions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>existsTrait</span> <span class=n>type</span> <span class=n>concreteTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>exists</span> <span class=n>type</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=kp>assumption</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>anyTrait</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span></code></pre></div><h3 id=tactic-destruct>Tactic <code>destruct</code><a hidden class=anchor aria-hidden=true href=#tactic-destruct>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>1</span> <span class=n>goal</span>
</span></span><span class=line><span class=cl><span class=n>Trait</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>Result</span> <span class=o>:</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>anyTrait</span> <span class=o>:</span> <span class=k>forall</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span>  <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span><span class=line><span class=cl><span class=n>existsTrait</span> <span class=o>:</span> <span class=k>exists</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=o>------------------------</span>
</span></span><span class=line><span class=cl><span class=n>Result</span>
</span></span></code></pre></div><p>At this point you might be tempted to try and apply <code>anyTrait</code> just like we did for our first goal, trying to switch the goal from result to <code>forall t : Type , Trait t</code>, however, this doesn&rsquo;t work with Coq complaining that <code>Unable to find an instance for the variable t</code>. This is because t is still universally quantified right now, whereas in our first goal t was existentially quantified. So we&rsquo;re going to need to find ourselves a <code>t: Type</code> before we can shift our goal.</p><p>We also have the <code>existsTrait: exists t : Type, Trait t</code> assumption. Luckily, when we have a term like this, we can ask Coq if this expression implies anything else that is not currently in our assumptions. We do this with the <code>inversion</code> or <code>destruct</code> tactics. Coq will auto-name the new assumptions but we can also give them meaningful names with <code>as</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>existsTrait</span> <span class=n>type</span> <span class=n>concreteTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>exists</span> <span class=n>type</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=kp>assumption</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>anyTrait</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>destruct</span> <span class=n>existsTrait</span> <span class=k>as</span> <span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>trait</span><span class=o>).</span>
</span></span></code></pre></div><h3 id=tactic-apply-_-with-_>Tactic <code>apply _ with _</code><a hidden class=anchor aria-hidden=true href=#tactic-apply-_-with-_>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>Trait</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>Result</span> <span class=o>:</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>anyTrait</span> <span class=o>:</span> <span class=k>forall</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span>
</span></span><span class=line><span class=cl><span class=n>trait</span> <span class=o>:</span> <span class=n>Trait</span> <span class=n>type</span>
</span></span><span class=line><span class=cl><span class=o>------------------------</span>
</span></span><span class=line><span class=cl><span class=n>Result</span>
</span></span></code></pre></div><p>Coq has broken apart <code>existsTrait</code> into its two assumptions. So now we have an assumption of kind <code>Type</code>! We can now solve the problem we had before about applying <code>anyTrait</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>existsTrait</span> <span class=n>type</span> <span class=n>concreteTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>exists</span> <span class=n>type</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=kp>assumption</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>anyTrait</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>destruct</span> <span class=n>existsTrait</span> <span class=k>as</span> <span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>trait</span><span class=o>).</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>anyTrait</span> <span class=k>with</span> <span class=n>t</span><span class=o>.</span>
</span></span></code></pre></div><h3 id=tactic-assumption-1>Tactic <code>assumption</code><a hidden class=anchor aria-hidden=true href=#tactic-assumption-1>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>Trait</span> <span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>Result</span> <span class=o>:</span> <span class=kt>Prop</span>
</span></span><span class=line><span class=cl><span class=n>anyTrait</span> <span class=o>:</span> <span class=k>forall</span> <span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span><span class=o>,</span> <span class=n>Trait</span> <span class=n>t</span> <span class=o>-&gt;</span> <span class=n>Result</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>:</span> <span class=kt>Type</span>
</span></span><span class=line><span class=cl><span class=n>trait</span> <span class=o>:</span> <span class=n>Trait</span> <span class=n>t</span>
</span></span><span class=line><span class=cl><span class=o>------------------------</span>
</span></span><span class=line><span class=cl><span class=n>Trait</span> <span class=n>t</span>
</span></span></code></pre></div><p>Now just like before, our goal matches one of our assumptions, so we can finish up this branch with <code>assumption</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>existsTrait</span> <span class=n>type</span> <span class=n>concreteTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>exists</span> <span class=n>type</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=kp>assumption</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>anyTrait</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>destruct</span> <span class=n>existsTrait</span> <span class=k>as</span> <span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>trait</span><span class=o>).</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>anyTrait</span> <span class=k>with</span> <span class=n>t</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=kp>assumption</span><span class=o>.</span>
</span></span></code></pre></div><h3 id=qed>QED<a hidden class=anchor aria-hidden=true href=#qed>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=n>No</span> <span class=n>more</span> <span class=n>goals</span><span class=o>.</span>
</span></span></code></pre></div><p>Now that we&rsquo;ve proved all of our goals, we get to do the best thing about formal verification. The sweet three-letter acronym. <strong>QED</strong>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-coq data-lang=coq><span class=line><span class=cl><span class=kn>Theorem</span> <span class=n>impl_trait_transform</span><span class=o>:</span> <span class=k>forall</span> <span class=o>(</span><span class=n>Trait</span><span class=o>:</span> <span class=kt>Type</span> <span class=o>-&gt;</span> <span class=kt>Prop</span><span class=o>)</span> <span class=o>(</span><span class=n>Result</span><span class=o>:</span> <span class=kt>Prop</span><span class=o>),</span>
</span></span><span class=line><span class=cl>  <span class=o>((</span><span class=k>exists</span> <span class=n>t</span><span class=o>,</span> <span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>))</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)</span> <span class=o>&lt;-&gt;</span> <span class=o>(</span><span class=k>forall</span> <span class=n>t</span><span class=o>,</span> <span class=o>(</span><span class=n>Trait</span><span class=o>(</span><span class=n>t</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>Result</span><span class=o>)).</span>
</span></span><span class=line><span class=cl><span class=kn>Proof</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=k>split</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>existsTrait</span> <span class=n>type</span> <span class=n>concreteTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>exists</span> <span class=n>type</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=kp>assumption</span><span class=o>.</span>
</span></span><span class=line><span class=cl>  <span class=o>-</span> <span class=k>intros</span> <span class=n>anyTrait</span> <span class=n>existsTrait</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=k>destruct</span> <span class=n>existsTrait</span> <span class=k>as</span> <span class=o>(</span><span class=n>t</span><span class=o>,</span> <span class=n>trait</span><span class=o>).</span>
</span></span><span class=line><span class=cl>    <span class=k>apply</span> <span class=n>anyTrait</span> <span class=k>with</span> <span class=n>t</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=kp>assumption</span><span class=o>.</span>
</span></span><span class=line><span class=cl><span class=kn>Qed</span><span class=o>.</span>
</span></span></code></pre></div><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>And there you go, we&rsquo;ve formally verified that our transformation from generic arguments with trait bounds into existential <code>impl Trait</code> arguments is always valid. Of course, Rust would not have implemented the feature had it not made sense, but I think it&rsquo;s gratifying to be able to prove such a cryptic statement like <code>((‚àÉ x. P(x)) ‚Üí Q) ‚áî (‚àÄ x. (P(x) ‚Üí Q))</code></p><p>Hopefully, this has given you a bit of a taste of how to reason when it comes to formally verifying programs which is such an interesting but alien style of programming. It feels like playing with Legos where the bricks are parts of your program. You know the final shape you want, you just have to keep exploring how they combine to get there. There is a deep connection between theorem proving and metaprogramming but that&rsquo;s a story for another time.</p><p>If you&rsquo;d like to explore more formal verification I&rsquo;d highly recommend checking out <a href=https://softwarefoundations.cis.upenn.edu/>Software Foundations</a> or Edwin Brady&rsquo;s <a href=https://www.manning.com/books/type-driven-development-with-idris>Type-Driven Development with Idris</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dylanj.xyz/tags/rust/>rust</a></li><li><a href=https://dylanj.xyz/tags/type-theory/>type theory</a></li><li><a href=https://dylanj.xyz/tags/formal-verification/>formal verification</a></li></ul><nav class=paginav><a class=next href=https://dylanj.xyz/posts/how-i-made-this-blog/><span class=title>Next ¬ª</span><br><span>How I Made This Blog</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://dylanj.xyz/>dylanj.xyz</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>