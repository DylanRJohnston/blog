<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Designing Cyclic Puzzles for Simon Says | dylanj.xyz</title>
<meta name=keywords content="game-design,rust,simon-says"><meta name=description content="I recently participated in the Bevy Jam 5 Game Jam, where the theme was &ldquo;Cycles&rdquo;. My take on this idea was Simon Says, a puzzle game where the player character must follow a series of instructions in a loop or cycle to complete the puzzle. While designing puzzles for this game, I quickly discovered a set of interesting mathematical properties underlying the solution space that I&rsquo;d like to show you."><meta name=author content="Dylan R. Johnston"><link rel=canonical href=https://dylanj.xyz/posts/simon-says-cyclic-puzzles/><link crossorigin=anonymous href=/assets/css/stylesheet.14ca24fd24e7cdc31db5d6bbcff6239501e0cc03e742237163e9913081d5b92f.css integrity="sha256-FMok/STnzcMdtda7z/YjlQHgzAPnQiNxY+mRMIHVuS8=" rel="preload stylesheet" as=style><link crossorigin=anonymous href=/css/extended/syntax.css rel="preload stylesheet" as=style><link rel=icon href=https://dylanj.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dylanj.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dylanj.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://dylanj.xyz/apple-touch-icon.png><link rel=mask-icon href=https://dylanj.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dylanj.xyz/posts/simon-says-cyclic-puzzles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.goat{font-size:.8em!important}code{text-size-adjust:100%;-ms-text-size-adjust:100%;-moz-text-size-adjust:100%;-webkit-text-size-adjust:100%}</style><meta property="og:title" content="Designing Cyclic Puzzles for Simon Says"><meta property="og:description" content="I recently participated in the Bevy Jam 5 Game Jam, where the theme was &ldquo;Cycles&rdquo;. My take on this idea was Simon Says, a puzzle game where the player character must follow a series of instructions in a loop or cycle to complete the puzzle. While designing puzzles for this game, I quickly discovered a set of interesting mathematical properties underlying the solution space that I&rsquo;d like to show you."><meta property="og:type" content="article"><meta property="og:url" content="https://dylanj.xyz/posts/simon-says-cyclic-puzzles/"><meta property="og:image" content="https://dylanj.xyz/posts/simon-says-cyclic-puzzles/images/IMG_0054.jpeg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-08T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-08T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dylanj.xyz/posts/simon-says-cyclic-puzzles/images/IMG_0054.jpeg"><meta name=twitter:title content="Designing Cyclic Puzzles for Simon Says"><meta name=twitter:description content="I recently participated in the Bevy Jam 5 Game Jam, where the theme was &ldquo;Cycles&rdquo;. My take on this idea was Simon Says, a puzzle game where the player character must follow a series of instructions in a loop or cycle to complete the puzzle. While designing puzzles for this game, I quickly discovered a set of interesting mathematical properties underlying the solution space that I&rsquo;d like to show you."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dylanj.xyz/posts/"},{"@type":"ListItem","position":2,"name":"Designing Cyclic Puzzles for Simon Says","item":"https://dylanj.xyz/posts/simon-says-cyclic-puzzles/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Designing Cyclic Puzzles for Simon Says","name":"Designing Cyclic Puzzles for Simon Says","description":"I recently participated in the Bevy Jam 5 Game Jam, where the theme was \u0026ldquo;Cycles\u0026rdquo;. My take on this idea was Simon Says, a puzzle game where the player character must follow a series of instructions in a loop or cycle to complete the puzzle. While designing puzzles for this game, I quickly discovered a set of interesting mathematical properties underlying the solution space that I\u0026rsquo;d like to show you.","keywords":["game-design","rust","simon-says"],"articleBody":"I recently participated in the Bevy Jam 5 Game Jam, where the theme was “Cycles”. My take on this idea was Simon Says, a puzzle game where the player character must follow a series of instructions in a loop or cycle to complete the puzzle. While designing puzzles for this game, I quickly discovered a set of interesting mathematical properties underlying the solution space that I’d like to show you.\nPuzzle Components I’ve played quite a few other “programming” style puzzle games like 7 Billion Humans (which is fantastic, check it out!), but they tend to incorporate many programming concepts such as conditional execution, goto statements, loops, sensors, etc. I wanted to keep my game simple to make it more approachable for non-programmers while staying true to the “Cycles” theme. This meant that whatever instructions were available must always execute in a loop so no branching / goto / etc. However, I also wanted to retain the interesting puzzle designs afforded by more complex constructs. So, I decided to try and “externalize” more complex programming concepts into environmental puzzle elements instead.\nWalls Walls may not seem like much at first glance, but they’re actually incredibly powerful as they act as a kind of conditional execution. When the character tries executes a move into a wall, it essentially becomes a no-op. This acts like an implicit if statement or continue statement:\nif next_block == WALL { continue; } You can see in this example, the solutions is ↑↑→→ but we have a maximum of three commands, normally ↑→ wouldn’t be enough to get around the corner, but thanks to the walls being placed where they are, we can conditionally execute the commands and make it around the corner.\nIt also has the effect of shifting the phase of the cycle forward by one, which I’ll discuss later when exploring solution symmetries.\nIce Ice acts as a nested loop. When a player steps onto ice, that move is repeated until they step onto a non-ice block or hit a wall:\nwhile current_block == ICE \u0026\u0026 next_block != WALL { walk(direction) } Here the solution if there was no ice would be ↑↑→→, but because of the looping nature of the nice we end up with ↑↑↑↑→→ and overshoot. Ice also helps us break up the cyclic symmetry of plans like ↑→↓←. The ice can allow one or more of the commands to loop ensuring we don’t just end up back where we started. Without ice these kinds of solutions lead to very boring puzzles.\nRotation The rotation blocks are more challenging to map onto traditional programming concepts; the closest analogy would be something akin to runtime metaprogramming. It’s like a program that rewrites your program by rotating all the instructions left or right. This allows the pre- and post-rotation parts of the puzzle to look very different while still having the same underlying solution. This also has an interesting interaction with walls: if your next move would push you into a wall, you stay on the rotation block and get rotated again, potentially rotating more than 90 degrees.\nThis can get complicated fast\nMultiple Players The multiple player characters are the first mechanic that doesn’t provide new tools but instead restricts the solution space. Since the puzzle is only completed when all players are on a finish block, despite looking more complicated, they actually drastically reduce the solution space to only solutions where their finishes coincide. You could argue this is somewhat analogous to synchronization points in multi-threaded programs.\nSymmetries It would be easy to bloat the game with many puzzles that are essentially the same, but I wanted each puzzle to either teach something new about the game’s ruleset or explore a genuinely novel solution. For example, a puzzle solved with → is exactly the same as a puzzle solved by going ↑, just rotated 90 degrees. This brings us to our first symmetry: rotation.\nRotation While it’s immediately obvious that the plan → is rotationally isomorphic to ↑, it becomes less obvious as the plans get more complex. For example, ↑→↑ is equivalent to ←↑← and →↓→. To make it easier to identify puzzles as being the same, we can start by “canonicalizing” the rotation of the solution by always rotating it so the first move is ↑.\nReflection Consider the solutions ↑→↑ and ↑←↑. These are just mirror images of each other and would yield puzzles that are mirror images as well, which is not very interesting. So we should consider them the same. We can canonicalize the “parity” of a solution by finding the first ← or →, and if it’s a ←, mirroring the puzzle so the first left or right is a right.\nPhase Because walls can shift the phase of a solution, we should also consider that often phase-shifted versions of the same plans are isomorphic for levels that use walls. For example, starting with the plan ↑→↑, if we shift the phase, it becomes →↑↑. However, under our previously established rules, we canonicalize its rotation to ↑←← and then its parity to ↑→→. It may seem counterintuitive that solutions ↑→↑ and ↑→→ are isomorphic under rotation, reflection, and phase shift, but if you spend some time thinking about it and rotating it in your head, it’ll become apparent.\nCycles Lastly, any plan with a cycle in it is isomorphic to its smaller plan, as all plans must execute in a loop. So ↑↑↑↑ is isomorphic to ↑.\nAll Novel Solutions With this understanding, we can now write a program that iterates over all possible solutions and maps them to their “canonical” version. I’ll list each of the phase-symmetric solutions together because not all puzzles involve walls, and so they sometimes are indeed novel solutions.\nOne Command Plans As we discussed earlier, there is only a single novel one-command solution: ↑. All other plans are just rotations of this plan.\nTwo Command Plans Initially, you might expect there to be quite a few of these as we now start with 4x4 possible plans, but there are actually only two: ↑→ and ↑↓. ↑↑ is just ↑, ↑← is the reflection of ↑→, and ↓↑ is the rotation of ↑↓.\nThree Command Plans You might think the solution space really opens up with three commands, but if you consider phase symmetry, there are actually only 3:\n↑ ↑ → ↑ → ↑ ↑ → → ↑ ↑ ↓ ↑ ↓ ↑ ↑ ↓ ↓ ↑ → ↓ ↑ → ← ↑ ↓ → Four Command Plans With 4^4 (i.e., 256) possible solutions, you might expect a decent number of novel solutions. However, omitting phase-symmetric solutions for brevity, there are only 11. All of the other 245 possible solutions are symmetries of these 11 or repeated cycles of smaller solutions:\n↑ ↑ ↑ → ↑ ↑ ↑ ↓ ↑ ↑ → → ↑ ↑ → ↓ ↑ ↑ → ← ↑ ↑ ↓ → ↑ ↑ ↓ ↓ ↑ → ↑ ↓ ↑ → ↑ ← ↑ → ↓ ← ↑ → ← ↓ Summary I hope you learnt something interesting today, unless you’re a group theorist in which case you were probably rolling your eyes about how obvious this all was. The Jam is currently still under voting but keep an eye out once its over as I have loads more ideas for interesting environmental puzzle mechanics.\n","wordCount":"1231","inLanguage":"en","image":"https://dylanj.xyz/posts/simon-says-cyclic-puzzles/images/IMG_0054.jpeg","datePublished":"2024-08-08T00:00:00Z","dateModified":"2024-08-08T00:00:00Z","author":{"@type":"Person","name":"Dylan R. Johnston"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dylanj.xyz/posts/simon-says-cyclic-puzzles/"},"publisher":{"@type":"Organization","name":"dylanj.xyz","logo":{"@type":"ImageObject","url":"https://dylanj.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dylanj.xyz/ accesskey=h title="dylanj.xyz (Alt + H)">dylanj.xyz</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://dylanj.xyz/archives title=Archives><span>Archives</span></a></li><li><a href=https://dylanj.xyz/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://dylanj.xyz/tags title=Tags><span>Tags</span></a></li><li><a href=https://dylanj.xyz/projects/ title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://dylanj.xyz/>Home</a>&nbsp;»&nbsp;<a href=https://dylanj.xyz/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Designing Cyclic Puzzles for Simon Says</h1><div class=post-meta><span title='2024-08-08 00:00:00 +0000 UTC'>August 8, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Dylan R. Johnston&nbsp;|&nbsp;<a href=https://github.com/dylanrjohnston/dylanrjohnston.github.io/tree/master/content/posts/simon-says-cyclic-puzzles/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager src=https://dylanj.xyz/posts/simon-says-cyclic-puzzles/images/IMG_0054.jpeg alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#puzzle-components aria-label="Puzzle Components">Puzzle Components</a><ul><li><a href=#walls aria-label=Walls>Walls</a></li><li><a href=#ice aria-label=Ice>Ice</a></li><li><a href=#rotation aria-label=Rotation>Rotation</a></li><li><a href=#multiple-players aria-label="Multiple Players">Multiple Players</a></li></ul></li><li><a href=#symmetries aria-label=Symmetries>Symmetries</a><ul><li><a href=#rotation-1 aria-label=Rotation>Rotation</a></li><li><a href=#reflection aria-label=Reflection>Reflection</a></li><li><a href=#phase aria-label=Phase>Phase</a></li><li><a href=#cycles aria-label=Cycles>Cycles</a></li></ul></li><li><a href=#all-novel-solutions aria-label="All Novel Solutions">All Novel Solutions</a><ul><li><a href=#one-command-plans aria-label="One Command Plans">One Command Plans</a></li><li><a href=#two-command-plans aria-label="Two Command Plans">Two Command Plans</a></li><li><a href=#three-command-plans aria-label="Three Command Plans">Three Command Plans</a></li><li><a href=#four-command-plans aria-label="Four Command Plans">Four Command Plans</a></li></ul></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></div></details></div><div class=post-content><p>I recently participated in the <a href=https://itch.io/jam/bevy-jam-5>Bevy Jam 5</a> Game Jam, where the theme was &ldquo;Cycles&rdquo;. My take on this idea was <a href=https://itch.io/jam/bevy-jam-5/rate/2853129>Simon Says</a>, a puzzle game where the player character must follow a series of instructions in a loop or cycle to complete the puzzle. While designing puzzles for this game, I quickly discovered a set of interesting mathematical properties underlying the solution space that I&rsquo;d like to show you.</p><p><img loading=lazy src=images/Aug-08-2024%2009-48-28.gif#center alt="I think I can, I think I can"></p><h1 id=puzzle-components>Puzzle Components<a hidden class=anchor aria-hidden=true href=#puzzle-components>#</a></h1><p>I&rsquo;ve played quite a few other &ldquo;programming&rdquo; style puzzle games like <a href="https://www.youtube.com/watch?v=Wo8gePOdv-k">7 Billion Humans</a> (which is fantastic, check it out!), but they tend to incorporate many programming concepts such as conditional execution, goto statements, loops, sensors, etc. I wanted to keep my game simple to make it more approachable for non-programmers while staying true to the &ldquo;Cycles&rdquo; theme. This meant that whatever instructions were available must always execute in a loop so no branching / goto / etc. However, I also wanted to retain the interesting puzzle designs afforded by more complex constructs. So, I decided to try and &ldquo;externalize&rdquo; more complex programming concepts into environmental puzzle elements instead.</p><h2 id=walls>Walls<a hidden class=anchor aria-hidden=true href=#walls>#</a></h2><p>Walls may not seem like much at first glance, but they&rsquo;re actually incredibly powerful as they act as a kind of conditional execution. When the character tries executes a move into a wall, it essentially becomes a no-op. This acts like an implicit <code>if</code> statement or <code>continue</code> statement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rs data-lang=rs><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=n>next_block</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=no>WALL</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=images/Aug-08-2024%2009-49-27.gif#center alt="Sometimes an obstacle is actually an opportunity"></p><p>You can see in this example, the solutions is <code>↑↑→→</code> but we have a maximum of three commands, normally <code>↑→</code> wouldn&rsquo;t be enough to get around the corner, but thanks to the walls being placed where they are, we can conditionally execute the commands and make it around the corner.</p><p>It also has the effect of shifting the phase of the cycle forward by one, which I&rsquo;ll discuss later when exploring solution symmetries.</p><h2 id=ice>Ice<a hidden class=anchor aria-hidden=true href=#ice>#</a></h2><p>Ice acts as a nested loop. When a player steps onto ice, that move is repeated until they step onto a non-ice block or hit a wall:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rs data-lang=rs><span class=line><span class=cl><span class=k>while</span><span class=w> </span><span class=n>current_block</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=no>ICE</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>next_block</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=no>WALL</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>walk</span><span class=p>(</span><span class=n>direction</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=images/Aug-08-2024%2009-51-08.gif#center alt="I left my skates at home"></p><p>Here the solution if there was no ice would be <code>↑↑→→</code>, but because of the looping nature of the nice we end up with <code>↑↑↑↑→→</code> and overshoot. Ice also helps us break up the cyclic symmetry of plans like <code>↑→↓←</code>. The ice can allow one or more of the commands to loop ensuring we don&rsquo;t just end up back where we started. Without ice these kinds of solutions lead to very boring puzzles.</p><h2 id=rotation>Rotation<a hidden class=anchor aria-hidden=true href=#rotation>#</a></h2><p>The rotation blocks are more challenging to map onto traditional programming concepts; the closest analogy would be something akin to runtime metaprogramming. It&rsquo;s like a program that rewrites your program by rotating all the instructions left or right. This allows the pre- and post-rotation parts of the puzzle to look very different while still having the same underlying solution. This also has an interesting interaction with walls: if your next move would push you into a wall, you stay on the rotation block and get rotated again, potentially rotating more than 90 degrees.</p><p><img loading=lazy src=images/Aug-08-2024%2009-52-15.gif#center alt="I meant to go this way"></p><p>This can get complicated fast</p><p><img loading=lazy src=images/simon_says.gif alt="All according to plan"></p><h2 id=multiple-players>Multiple Players<a hidden class=anchor aria-hidden=true href=#multiple-players>#</a></h2><p>The multiple player characters are the first mechanic that doesn&rsquo;t provide new tools but instead restricts the solution space. Since the puzzle is only completed when all players are on a finish block, despite looking more complicated, they actually drastically reduce the solution space to only solutions where their finishes coincide. You could argue this is somewhat analogous to synchronization points in multi-threaded programs.</p><p><img loading=lazy src=images/Aug-08-2024%2009-54-06.gif#center alt="Like ships in the night"></p><h1 id=symmetries>Symmetries<a hidden class=anchor aria-hidden=true href=#symmetries>#</a></h1><p>It would be easy to bloat the game with many puzzles that are essentially the same, but I wanted each puzzle to either teach something new about the game&rsquo;s ruleset or explore a genuinely novel solution. For example, a puzzle solved with <code>→</code> is exactly the same as a puzzle solved by going <code>↑</code>, just rotated 90 degrees. This brings us to our first symmetry: rotation.</p><h2 id=rotation-1>Rotation<a hidden class=anchor aria-hidden=true href=#rotation-1>#</a></h2><p>While it&rsquo;s immediately obvious that the plan <code>→</code> is rotationally isomorphic to <code>↑</code>, it becomes less obvious as the plans get more complex. For example, <code>↑→↑</code> is equivalent to <code>←↑←</code> and <code>→↓→</code>. To make it easier to identify puzzles as being the same, we can start by &ldquo;canonicalizing&rdquo; the rotation of the solution by always rotating it so the first move is <code>↑</code>.</p><h2 id=reflection>Reflection<a hidden class=anchor aria-hidden=true href=#reflection>#</a></h2><p>Consider the solutions <code>↑→↑</code> and <code>↑←↑</code>. These are just mirror images of each other and would yield puzzles that are mirror images as well, which is not very interesting. So we should consider them the same. We can canonicalize the &ldquo;parity&rdquo; of a solution by finding the first <code>←</code> or <code>→</code>, and if it&rsquo;s a <code>←</code>, mirroring the puzzle so the first left or right is a right.</p><h2 id=phase>Phase<a hidden class=anchor aria-hidden=true href=#phase>#</a></h2><p>Because walls can shift the phase of a solution, we should also consider that often phase-shifted versions of the same plans are isomorphic for levels that use walls. For example, starting with the plan <code>↑→↑</code>, if we shift the phase, it becomes <code>→↑↑</code>. However, under our previously established rules, we canonicalize its rotation to <code>↑←←</code> and then its parity to <code>↑→→</code>. It may seem counterintuitive that solutions <code>↑→↑</code> and <code>↑→→</code> are isomorphic under rotation, reflection, and phase shift, but if you spend some time thinking about it and rotating it in your head, it&rsquo;ll become apparent.</p><h2 id=cycles>Cycles<a hidden class=anchor aria-hidden=true href=#cycles>#</a></h2><p>Lastly, any plan with a cycle in it is isomorphic to its smaller plan, as all plans must execute in a loop. So <code>↑↑↑↑</code> is isomorphic to <code>↑</code>.</p><h1 id=all-novel-solutions>All Novel Solutions<a hidden class=anchor aria-hidden=true href=#all-novel-solutions>#</a></h1><p>With this understanding, we can now write a program that iterates over all possible solutions and maps them to their &ldquo;canonical&rdquo; version. I&rsquo;ll list each of the phase-symmetric solutions together because not all puzzles involve walls, and so they sometimes are indeed novel solutions.</p><h2 id=one-command-plans>One Command Plans<a hidden class=anchor aria-hidden=true href=#one-command-plans>#</a></h2><p>As we discussed earlier, there is only a single novel one-command solution: <code>↑</code>. All other plans are just rotations of this plan.</p><h2 id=two-command-plans>Two Command Plans<a hidden class=anchor aria-hidden=true href=#two-command-plans>#</a></h2><p>Initially, you might expect there to be quite a few of these as we now start with 4x4 possible plans, but there are actually only two: <code>↑→</code> and <code>↑↓</code>. <code>↑↑</code> is just <code>↑</code>, <code>↑←</code> is the reflection of <code>↑→</code>, and <code>↓↑</code> is the rotation of <code>↑↓</code>.</p><h2 id=three-command-plans>Three Command Plans<a hidden class=anchor aria-hidden=true href=#three-command-plans>#</a></h2><p>You might think the solution space really opens up with three commands, but if you consider phase symmetry, there are actually only 3:</p><ul><li>↑ ↑ →<ul><li>↑ → ↑</li><li>↑ → →</li></ul></li><li>↑ ↑ ↓<ul><li>↑ ↓ ↑</li><li>↑ ↓ ↓</li></ul></li><li>↑ → ↓<ul><li>↑ → ←</li><li>↑ ↓ →</li></ul></li></ul><h2 id=four-command-plans>Four Command Plans<a hidden class=anchor aria-hidden=true href=#four-command-plans>#</a></h2><p>With 4^4 (i.e., 256) possible solutions, you might expect a decent number of novel solutions. However, omitting phase-symmetric solutions for brevity, there are only 11. All of the other 245 possible solutions are symmetries of these 11 or repeated cycles of smaller solutions:</p><ul><li>↑ ↑ ↑ →</li><li>↑ ↑ ↑ ↓</li><li>↑ ↑ → →</li><li>↑ ↑ → ↓</li><li>↑ ↑ → ←</li><li>↑ ↑ ↓ →</li><li>↑ ↑ ↓ ↓</li><li>↑ → ↑ ↓</li><li>↑ → ↑ ←</li><li>↑ → ↓ ←</li><li>↑ → ← ↓</li></ul><h1 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h1><p>I hope you learnt something interesting today, unless you&rsquo;re a group theorist in which case you were probably rolling your eyes about how obvious this all was. The Jam is currently still under voting but keep an eye out once its over as I have loads more ideas for interesting environmental puzzle mechanics.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://dylanj.xyz/tags/game-design/>Game-Design</a></li><li><a href=https://dylanj.xyz/tags/rust/>Rust</a></li><li><a href=https://dylanj.xyz/tags/simon-says/>Simon-Says</a></li></ul><nav class=paginav><a class=next href=https://dylanj.xyz/posts/rust-coq-opaque-types/><span class=title>Next »</span><br><span>Formally Verifying Rust's Opaque Types</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://dylanj.xyz/>dylanj.xyz</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>